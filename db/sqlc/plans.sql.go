// Code generated by sqlc. DO NOT EDIT.
// source: plans.sql

package db

import (
	"context"
)

const createPlan = `-- name: CreatePlan :one
INSERT INTO plans (
name,
description,
price,
no_of_days
) VALUES
($1, $2, $3, $4) RETURNING id, name, description, price, no_of_days, created_at
`

type CreatePlanParams struct {
	Name        string  `json:"name"`
	Description string  `json:"description"`
	Price       float64 `json:"price"`
	NoOfDays    int32   `json:"no_of_days"`
}

func (q *Queries) CreatePlan(ctx context.Context, arg CreatePlanParams) (Plan, error) {
	row := q.db.QueryRowContext(ctx, createPlan,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.NoOfDays,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.NoOfDays,
		&i.CreatedAt,
	)
	return i, err
}

const deletePlan = `-- name: DeletePlan :exec
DELETE from plans
WHERE id = $1
`

func (q *Queries) DeletePlan(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePlan, id)
	return err
}

const getPlan = `-- name: GetPlan :one
SELECT id, name, description, price, no_of_days, created_at from plans
WHERE id = $1
`

func (q *Queries) GetPlan(ctx context.Context, id int32) (Plan, error) {
	row := q.db.QueryRowContext(ctx, getPlan, id)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.NoOfDays,
		&i.CreatedAt,
	)
	return i, err
}

const updatePlan = `-- name: UpdatePlan :one
UPDATE plans SET
 name = CASE WHEN $1::boolean
        THEN $2::text ELSE name END, 
 description = CASE WHEN $3::boolean
        THEN $4::text ELSE description END,
 price = CASE WHEN $5::boolean
        THEN $6::float ELSE price END,
 no_of_days = CASE WHEN $7::boolean
        THEN $8::int ELSE no_of_days END
WHERE id = $9 RETURNING id, name, description, price, no_of_days, created_at
`

type UpdatePlanParams struct {
	NameToUpdate        bool    `json:"name_to_update"`
	Name                string  `json:"name"`
	DescriptionToUpdate bool    `json:"description_to_update"`
	Description         string  `json:"description"`
	PriceToUpdate       bool    `json:"price_to_update"`
	Price               float64 `json:"price"`
	NoOfDaysToUpdate    bool    `json:"no_of_days_to_update"`
	NoOfDays            int32   `json:"no_of_days"`
	ID                  int32   `json:"id"`
}

func (q *Queries) UpdatePlan(ctx context.Context, arg UpdatePlanParams) (Plan, error) {
	row := q.db.QueryRowContext(ctx, updatePlan,
		arg.NameToUpdate,
		arg.Name,
		arg.DescriptionToUpdate,
		arg.Description,
		arg.PriceToUpdate,
		arg.Price,
		arg.NoOfDaysToUpdate,
		arg.NoOfDays,
		arg.ID,
	)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.NoOfDays,
		&i.CreatedAt,
	)
	return i, err
}
