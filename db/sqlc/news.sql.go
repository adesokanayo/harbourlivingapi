// Code generated by sqlc. DO NOT EDIT.
// source: news.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createNews = `-- name: CreateNews :one
INSERT INTO news (
    title,
    description,
    feature_image,
    body,
    user_id,
    publish_date,
    tags,
    status
) VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8 ) RETURNING id, title, description, feature_image, body, user_id, status, publish_date, tags, created_at
`

type CreateNewsParams struct {
	Title        string         `json:"title"`
	Description  string         `json:"description"`
	FeatureImage sql.NullString `json:"feature_image"`
	Body         string         `json:"body"`
	UserID       int32          `json:"user_id"`
	PublishDate  time.Time      `json:"publish_date"`
	Tags         sql.NullString `json:"tags"`
	Status       int32          `json:"status"`
}

func (q *Queries) CreateNews(ctx context.Context, arg CreateNewsParams) (News, error) {
	row := q.db.QueryRowContext(ctx, createNews,
		arg.Title,
		arg.Description,
		arg.FeatureImage,
		arg.Body,
		arg.UserID,
		arg.PublishDate,
		arg.Tags,
		arg.Status,
	)
	var i News
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FeatureImage,
		&i.Body,
		&i.UserID,
		&i.Status,
		&i.PublishDate,
		&i.Tags,
		&i.CreatedAt,
	)
	return i, err
}

const deleteNews = `-- name: DeleteNews :exec
DELETE FROM news
WHERE id = $1
`

func (q *Queries) DeleteNews(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteNews, id)
	return err
}

const getAllNews = `-- name: GetAllNews :many
SELECT id, title, description, feature_image, body, user_id, status, publish_date, tags, created_at from news
order by id desc
`

func (q *Queries) GetAllNews(ctx context.Context) ([]News, error) {
	rows, err := q.db.QueryContext(ctx, getAllNews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []News{}
	for rows.Next() {
		var i News
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FeatureImage,
			&i.Body,
			&i.UserID,
			&i.Status,
			&i.PublishDate,
			&i.Tags,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNews = `-- name: GetNews :one
SELECT id, title, description, feature_image, body, user_id, status, publish_date, tags, created_at FROM news
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetNews(ctx context.Context, id int32) (News, error) {
	row := q.db.QueryRowContext(ctx, getNews, id)
	var i News
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FeatureImage,
		&i.Body,
		&i.UserID,
		&i.Status,
		&i.PublishDate,
		&i.Tags,
		&i.CreatedAt,
	)
	return i, err
}

const updateNews = `-- name: UpdateNews :one
UPDATE news SET
 title = CASE WHEN $1::boolean
        THEN $2::text ELSE title END, 
 description = CASE WHEN $3::boolean
        THEN $4::text ELSE description END,
 feature_image = CASE WHEN $5::boolean
        THEN $6::text ELSE feature_image END,
 body = CASE WHEN $7::boolean
        THEN $8::text ELSE body END,
 publish_date = CASE WHEN $9::boolean
        THEN $10::timestamptz ELSE publish_date END,
 tags = CASE WHEN $11::boolean
        THEN $12::text ELSE tags END,
status = CASE WHEN $13::boolean
        THEN $14::int ELSE status END
WHERE id = $15 RETURNING id, title, description, feature_image, body, user_id, status, publish_date, tags, created_at
`

type UpdateNewsParams struct {
	TitleIDToUpdate      bool      `json:"title_id_to_update"`
	Title                string    `json:"title"`
	DescriptionToUpdate  bool      `json:"description_to_update"`
	Description          string    `json:"description"`
	FeatureImageToUpdate bool      `json:"feature_image_to_update"`
	FeatureImage         string    `json:"feature_image"`
	BodyToUpdate         bool      `json:"body_to_update"`
	Body                 string    `json:"body"`
	PublishDateToUpdate  bool      `json:"publish_date_to_update"`
	PublishDate          time.Time `json:"publish_date"`
	TagsDateToUpdate     bool      `json:"tags_date_to_update"`
	Tags                 string    `json:"tags"`
	StatusToUpdate       bool      `json:"status_to_update"`
	Status               int32     `json:"status"`
	ID                   int32     `json:"id"`
}

func (q *Queries) UpdateNews(ctx context.Context, arg UpdateNewsParams) (News, error) {
	row := q.db.QueryRowContext(ctx, updateNews,
		arg.TitleIDToUpdate,
		arg.Title,
		arg.DescriptionToUpdate,
		arg.Description,
		arg.FeatureImageToUpdate,
		arg.FeatureImage,
		arg.BodyToUpdate,
		arg.Body,
		arg.PublishDateToUpdate,
		arg.PublishDate,
		arg.TagsDateToUpdate,
		arg.Tags,
		arg.StatusToUpdate,
		arg.Status,
		arg.ID,
	)
	var i News
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FeatureImage,
		&i.Body,
		&i.UserID,
		&i.Status,
		&i.PublishDate,
		&i.Tags,
		&i.CreatedAt,
	)
	return i, err
}
